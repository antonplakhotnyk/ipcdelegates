#pragma once

// virutal AVObject::Uninit() метод
//		Гарантировано вызывается
//		В момент вызова класс полностью живой и его хендлеры живые (удаление ещё не началось)
//
// AVObject::AddChild(AVObject* child)
// AVObject::RemoveChild(AVObject* child)
//		Добавляет удаляет объекты в список с увеличением количества ссылок для продления времени жизни
//
// AVObject::SubscribeDelete(AVObject* handler)
// AVObject::UnsubscribeDelete(AVObject* handler)
//		Подписывает и отписывает объект handler на нотификации об удалении объекта this 
//		Ведётся подсчёт количества подписываний для каждого объекта, аналогично счётчику ссылок. 
//
// virtual AVObject::OnDelete(void* destroyed);
//		Нотификация об удалении объекта destroyed. Который по своей природе AVObject
//		который на момент нотификации в процессе удаления, и в него нельзя звонить,
//		его можно только сравнивать с AVObject* для того чтобы корректно поотписываться от 
//		экземпляров этого класса (т.к. в конце удаления указатели на этот экземпляр будут удалены)
//
// Базовые классы
//		AVRefCounter
//		AVDeleteNotify
//		ChildrenStorage
//		Uninit
//		Cleaner
//
// * ОБработчики (Handlers)
//
// Cleaner::Cleaner(AVObject* parent, Template& cleaned);
//		В процессе удаления очищает объект cleaned путём cleaned=Template();
//
// Указатели на обработчики хранятся в делегатах как без подсчёта ссылок по умолчанию, 
//		но могут храниться и с подсчётом ссылок.
//		
// Делегаты обрабатывают уведомления об удалении обработчика, очищая указатель на обработчика
//
// * Указатели и подсчёт ссылок.
//
// SmartPtr
//		Нужно три из трёх. 
//			* Консистентность (указатели меняются только явными операциями)
//			* Доступность (не нулевой указатель - валидный)
//			* Удаление при нербходимости (возможность удалить объект немедленно, delete on demand)
//		Принудительно удалять всех причастных
//			Казалось бы это можно достигнуть если в процессе принудительного удаления 
//			принудительно удалять всех кто ссылается на удаляемый объект (получится рекурсивное удаление).
//			Но нет, т.к. в процессе удаления будет нарушена либо доступность либо консистентность. 
//			Это будет явной операцией, не нулевые указатели останутся валидными, 
//			удаление произойдёт внутри функции удаления. Но может попутно удалить вообще всё.
//			Это невозможно крайне тяжело реализовать в рамках С++ т.к. нужно надёжно обнаружить
//			все объекты содержащие ссылки на указанный объект.
//		Уведомлять о грядущем удалении с тем чтобы обработчик уведомления избавился от ссылок на удаляемый объект.
//			Это вообще не решение т.к. нету видимых гарантий избавился от ссылок на удаляемый объект
//			и количество ссылок может оставаться больше нуля даже после такого уведомления.
//		
// Удаление
//		* Счётчик ссылок стал нулевым
//			разослать уведомления
//			почистить все weak-ptr
//			удалить объект (оператором delete)
//		* принудительнеое удаление (счётчик указатель верхнего уровня supper-owner стал нулевым)
//			Удалить принудительно всех "родителей" содержащих ссылки на удаляемый объект (рекурсивно)
//			в случае если после удаления "родителей" счётчик ссылок не достиг нуля - выводить ошибку удаления
//			которая по сути означает баг-мемори лик в следствии скрытых циклических ссылок.
//
// Базовый класс с подсчётом ссылок, отдельно от базового класса с нотификациями
//
// DPtr - Data Pointer
//		Хранит указатели на объекты без ссылок и хендлеров не являющиеся наследником AVObject
//		* внутри таких обектов нельзя использовать указатели с подсчётом ссылок т.к.
//		цыклические ссылки никак не обрабатываются.
//		* Не присылает никаких уведомлений об удалении
//		* Можно передавать в другие потоки.
//
// WPtrNotify - Weak Pointer
//		Указатель без подсчёта ссылок
//
// OPtr - Owner Pointer
//		Указатель увеличивающий количество ссылок
//
// WOPtr - Weak Owner Pointer
//		Указатель увеличивающий подсчёт ссылок, 
//		автоматически зануляется при удалении объекта по достижению нуля количества ссылок высшего уровня
//		получает родителя в свой конструктор.
//
// SOPtr - Supper Owner Pointer
//		Указатель увеличивающий подсчёт ссылок более высокого (верхнего) уровня
//		Управляет дополнительным счётчиком указателей верхнего уровня, по обнулению которого
//		вызывается Uninit и прочие очистки с целью поразрывать ссылки так, 
//		чтоб удалились все чаилды
//
// NPtr - Notify Pointer
//		* Специальный шаблонный указатель который автоматически подписывает и отписывает 
//		один объект на уведомления об удалении другого. В качестве шаблона подставляется другой умный указатель
//		* Это наследник OPtr который в добавок делает SubscribeDelete/UnsubscribeDelete 
//		* Получатель нотификаций хранится без увеличения счётчика ссылок (weak-ptr)
//			т.к. нет смысла ждать уведомление об уничтожении если сам держишь ссылку
//		При копировании:
//		NPtr <- NPtr хранит новое значение отправителя и получателя
//			Получатель нотификации копируется из ONPtr в ONPtr (всегда)
//		NPtr <- Ptr хранит старое значение получателя и новое (Ptr) отправителя.
//			из объекта (не NPtr) в NPtr получатель нотификаций уже присутствующий в NPtr 
//			подписывается на нотификации об объекте (не NPtr).
//
// Есть указатели верхнего структурного уровня, и нижнего струкнурного уровня.
//		Указатели нижнего уровня - очищаются когда объект уничтожается (weak-ptr)
//		Объект удаляется когда исчезают указатели верхнего уровня (owner-count).
//		Уровней может быть сколько угодно много.

//-------------------------------------------------------

#include "AVWeakBase.h"
#include "AVRefCounter.h"
#include "AVNotifyBase.h"

#define AVBaseObject AVObject
#define AVBaseWeak AVNotifyWeakBase
#define AVBaseStrong AVRefCounter

class AVObject: public AVNotifyWeakBase, public AVRefCounter
{
protected:

	void OnSelfZeroRef() const override
	{
		AVNotifyWeakBase::Process_OnSelfZeroRef(&m_notifications);
	}

};